[
  {
    "title": "What is Object Oriented Programming (OOPs)?",
    "question": "What is Object Oriented Programming (OOPs)?",
    "answer": "Object-Oriented Programming (OOP) is a programming paradigm based on the concept of \"objects,\" which can contain data in the form of fields (attributes or properties) and code in the form of procedures (methods or functions). OOP focuses on organizing software into objects that interact with each other to accomplish tasks.\n\nOOP promotes modular, maintainable, and scalable software development by organizing code into reusable and understandable components. It emphasizes concepts such as data encapsulation, code reuse, and separation of concerns, which contribute to building robust and flexible software systems.",
    "topic": "oop"
  },
  {
    "title": "4 Pillars of OOPs",
    "question": "What are the 4 pillars of OOPs?",
    "answer": "The four fundamental principles of Object-Oriented Programming (OOP) are commonly referred to as the \"Four Pillars of OOP.\" They are:\n\nEncapsulation:\nEncapsulation refers to the bundling of data (attributes or properties) and methods (functions or procedures) that operate on the data into a single unit, called a class.\nIt allows the internal state of an object to be hidden from outside interference and accessed only through well-defined interfaces (public methods).\nEncapsulation provides data protection, abstraction, and modularity, enhancing code maintainability and reusability.\n\nInheritance:\nInheritance is a mechanism that allows a class (subclass or derived class) to inherit properties and behavior (methods) from another class (superclass or base class).\nIt promotes code reuse by enabling subclasses to inherit and extend the functionality defined in their superclass.\nInheritance facilitates the creation of a hierarchy of classes with specialized behavior, promoting code organization and scalability.\n\nPolymorphism:\nPolymorphism enables objects to be treated as instances of their superclass, allowing them to take on multiple forms.\nIt allows different objects to respond to the same message (method call) in different ways, based on their specific implementations.\nPolymorphism simplifies code by allowing methods to be written to work with objects of a superclass, without needing to know the exact subclass at compile time.\nPolymorphism is achieved through method overriding and method overloading.\n\nAbstraction:\nAbstraction involves simplifying complex systems by focusing on the essential properties while hiding unnecessary details.\nIt allows developers to create abstract classes and interfaces to define common behavior without specifying implementation details.\nAbstraction helps in managing complexity, improving code maintainability, and promoting code reuse by providing a clear separation between interface and implementation.\n\nThese four principles form the foundation of Object-Oriented Programming and guide the design and implementation of software systems, promoting modular, maintainable, and scalable code.",
    "topic": "oop"
  },
  {
    "title": "Compile Time vs Runtime Polymorphism",
    "question": "What is Compile Time Polymorphism and Runtime Polymorphism?",
    "answer": "Compile-time polymorphism and runtime polymorphism are two forms of polymorphism in object-oriented programming. They occur at different stages of program execution and are achieved through method overloading and method overriding, respectively.\n\nCompile-Time Polymorphism (Static Binding):\nCompile-time polymorphism occurs when the decision about which method to call is made at compile time based on the method signature.\nIt is achieved through method overloading, where multiple methods with the same name but different parameter lists (number or type of parameters) are defined within the same class.\nThe compiler determines the appropriate method to invoke based on the number and types of arguments provided in the method call.\nCompile-time polymorphism is also known as static binding because the method call is resolved at compile time and cannot be changed at runtime.\n```java\nclass Calculator {\n    // Method overloading\n    int add(int a, int b) {\n        return a + b;\n    }\n\n    double add(double a, double b) {\n        return a + b;\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Calculator calc = new Calculator();\n        int result1 = calc.add(2, 3);          // Calls int add(int a, int b)\n        double result2 = calc.add(2.5, 3.5);   // Calls double add(double a, double b)\n    }\n}\n```\n\nRuntime Polymorphism (Dynamic Binding):\nRuntime polymorphism occurs when the decision about which method to call is made at runtime based on the actual type of the object.\nIt is achieved through method overriding, where a subclass provides a specific implementation of a method that is already defined in its superclass.\nThe JVM determines the appropriate method to invoke based on the actual object type (not the reference type) at runtime.\nRuntime polymorphism allows for flexibility and extensibility in object-oriented designs, as it enables subclass objects to exhibit behavior specific to their type.\n```java\nclass Animal {\n    void sound() {\n        System.out.println(\"Animal makes a sound\");\n    }\n}\n\nclass Dog extends Animal {\n    @Override\n    void sound() {\n        System.out.println(\"Dog barks\");\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Animal animal = new Dog();  // Upcasting\n        animal.sound();             // Calls Dog's overridden method\n    }\n}\n```\n\nIn summary, compile-time polymorphism is achieved through method overloading and resolved at compile time, while runtime polymorphism is achieved through method overriding and resolved at runtime based on the actual object type. Each form of polymorphism provides flexibility and allows for code reuse in object-oriented programming.",
    "topic": "oop"
  },
  {
    "title": "Types of Inheritance",
    "question": "What are the different types of inheritance?",
    "answer": "Inheritance is a fundamental concept in object-oriented programming that allows a class (subclass or derived class) to inherit properties and behavior (methods) from another class (superclass or base class). There are several types of inheritance, based on the relationship between the subclass and superclass:\n\nSingle Inheritance:\nSingle inheritance occurs when a subclass inherits from only one superclass.\nIt is the simplest form of inheritance and is widely supported in most object-oriented programming languages.\n```java\nclass Animal {\n    // Animal properties and methods\n}\n\nclass Dog extends Animal {\n    // Dog inherits from Animal\n}\n```\n\nMultilevel Inheritance:\nMultilevel inheritance occurs when a subclass inherits from another subclass, forming a chain of inheritance.\nIt allows for the creation of a hierarchy of classes with multiple levels of specialization.\n```java\nclass Animal {\n    // Animal properties and methods\n}\n\nclass Mammal extends Animal {\n    // Mammal inherits from Animal\n}\n\nclass Dog extends Mammal {\n    // Dog inherits from Mammal\n}\n```\n\nHierarchical Inheritance:\nHierarchical inheritance occurs when multiple subclasses inherit from the same superclass.\nIt allows for the creation of a hierarchy of classes with different levels of specialization, branching out from a common superclass.\n```java\nclass Animal {\n    // Animal properties and methods\n}\n\nclass Dog extends Animal {\n    // Dog inherits from Animal\n}\n\nclass Cat extends Animal {\n    // Cat inherits from Animal\n}\n```\n\nMultiple Inheritance via Interfaces in Java:\nMultiple inheritance occurs when a subclass inherits from multiple superclasses.\nWhile Java does not support multiple inheritance of classes due to the diamond problem, it supports multiple inheritance through interfaces.\nInterfaces in Java allow a class to inherit abstract methods from multiple interfaces, enabling a form of multiple inheritance.\n```java\ninterface Swimmer {\n    void swim();\n}\n\ninterface Flyer {\n    void fly();\n}\n\nclass Bird implements Swimmer, Flyer {\n    // Bird implements both Swimmer and Flyer interfaces\n}\n```",
    "topic": "oop"
  },
  {
    "title": "Diamond Problem in Java",
    "question": "What is the diamond problem in Java?",
    "answer": "The diamond problem occurs when a class inherits from two or more classes, each of which inherits from the same superclass. This creates a diamond-shaped inheritance hierarchy, where a subclass inherits the same superclass through multiple paths.\n\nThe problem arises when the subclass attempts to inherit or override a method from the common superclass. In such cases, the compiler may not be able to determine which version of the method to use, leading to ambiguity and potential conflicts.\n\n    A\n   / \\\n  B   C\n   \\ /\n    D\n\nIn this diamond-shaped inheritance hierarchy, both classes B and C inherit from class A, and class D inherits from both B and C. If class A has a method foo(), and classes B and C override foo() with different implementations, the compiler may not be able to determine which version of foo() to use in class D.\n\nIn Java, the diamond problem is avoided by allowing single inheritance of classes and supporting multiple inheritance only through interfaces. Interfaces do not contain any implementation, so there is no ambiguity in method resolution.",
    "topic": "oop"
  },
  {
    "title": "Abstract Class vs Interface",
    "question": "What is the difference between abstract class and interface?",
    "answer": "Abstract classes and interfaces are both used to achieve abstraction and define contracts for classes in Java, but they have some key differences:\n\nAbstract Class:\nAn abstract class is a class that cannot be instantiated on its own and may contain abstract methods (methods without implementation) as well as concrete methods (methods with implementation).\nAbstract classes can have constructors, instance variables, and non-abstract methods, in addition to abstract methods.\nA subclass must provide implementations for all abstract methods defined in its abstract superclass, or it must itself be declared abstract.\nAbstract classes are used to define common behavior and characteristics shared among subclasses, serving as a blueprint for creating concrete subclasses.\n```java\nabstract class Shape {\n    // Abstract method\n    abstract double area();\n\n    // Concrete method\n    void display() {\n        System.out.println(\"Displaying shape\");\n    }\n}\n```\n\nInterface:\nAn interface is a reference type similar to a class but contains only abstract methods, constants (static final fields), and default/static methods (methods with default implementations).\nInterfaces cannot have constructors or instance variables, only method signatures.\nA class implements an interface by providing concrete implementations for all the methods declared in the interface.\nInterfaces are used to define contracts that classes can choose to implement, enabling multiple inheritance of type (a class can implement multiple interfaces).\n```java\ninterface Drawable {\n    // Abstract method\n    void draw();\n}\n```\n\nKey Differences:\nAn abstract class can have both abstract and concrete methods, while an interface can have abstract methods, default methods, and static methods.\nA class can extend only one abstract class, but it can implement multiple interfaces.\nAbstract classes can have constructors, whereas interfaces cannot.\nAbstract classes are used to provide a common base for subclasses to extend, while interfaces define contracts that classes can implement to achieve polymorphism.\n```java\n// Abstract class\nabstract class Animal {\n    private String name;\n\n    // Constructor in abstract class\n    public Animal(String name) {\n        this.name = name;\n    }\n\n    // Abstract method (no implementation)\n    public abstract void makeSound();\n\n    // Concrete method\n    public void sleep() {\n        System.out.println(name + \" is sleeping.\");\n    }\n}\n\n// Interface with abstract methods and default method\ninterface Pet {\n    // Abstract method\n    void play();\n\n    // Default method (concrete method)\n    default void beFriendly() {\n        System.out.println(\"Being friendly.\");\n    }\n\n    // Static method (concrete method)\n    static void showAffection() {\n        System.out.println(\"Showing affection.\");\n    }\n}\n\n// Class that extends abstract class and implements interface\nclass Dog extends Animal implements Pet {\n    public Dog(String name) {\n        super(name); // Call the constructor of the abstract class\n    }\n\n    @Override\n    public void makeSound() {\n        System.out.println(\"Dog barks.\");\n    }\n\n    @Override\n    public void play() {\n        System.out.println(\"Dog is playing.\");\n    }\n}\n```",
    "topic": "oop"
  },
  {
    "title": "When to Use Abstract Class vs Interface",
    "question": "When should you use an abstract class versus an interface?",
    "answer": "Use Interface When:\n\nA is capable of [doing this] scenario fits in your requirement. For example: below Programmable interface is capable of doing Programming\n```java\ninterface Programmable {\n        void programming();\n}\n```\nYou want to define a contract for classes to implement: Interfaces specify a set of methods that implementing classes must provide, defining a clear contract for how classes interact with each other.\nYou want to achieve multiple inheritance of type: Classes can implement multiple interfaces, allowing them to inherit behavior from multiple sources without the restrictions of single inheritance.\nYou want to decouple implementation from interface: Interfaces provide a way to separate the specification of behavior from its implementation, promoting loose coupling and flexibility in design.\n\nUse Abstract Class When:\nA is B or C is B scenario fits in your requirement, for example: Dog is Animal, Cat is Animal..etc.\nYou want to provide a common base implementation for subclasses: Abstract classes can contain both abstract and concrete methods, allowing you to define common behavior that subclasses can inherit.\nYou want to define a class hierarchy: Abstract classes are useful for creating a hierarchical structure of classes where each subclass represents a more specialized version of the superclass.\nYou want to share code among closely related classes: Abstract classes can contain state and behavior that is common to multiple subclasses, reducing code duplication.",
    "topic": "oop"
  },
  {
    "title": "Constructors in Java",
    "question": "What is a Constructor and what are the different types of Constructors?",
    "answer": "A constructor in Java is a special type of method that is automatically called when an instance (object) of a class is created. It is used to initialize the newly created object and set its initial state. Constructors have the same name as the class and do not have a return type, not even void.\n\nThere are several types of constructors in Java:\n\nDefault Constructor:\nA default constructor is a non-parameterized constructor automatically provided by the Java compiler if no other constructor is explicitly defined in a class.\nIt initializes the object with default values (e.g., numeric fields are initialized to 0, references are initialized to null).\n```java\npublic class MyClass {\n    // Default constructor\n    public MyClass() {\n        // Constructor body\n    }\n}\n```\n\nParameterized Constructor:\nA parameterized constructor is a constructor with parameters that allows you to initialize the object with specific values passed as arguments.\nIt enables you to customize the initialization of objects based on the values provided at the time of object creation.\n```java\npublic class MyClass {\n    // Parameterized constructor\n    public MyClass(int x, int y) {\n        // Constructor body\n    }\n}\n```\n\nCopy Constructor:\nA copy constructor is a constructor that initializes an object by copying the state of another object of the same class.\nIt allows you to create a new object with the same state as an existing object, providing a convenient way to clone objects.\n```java\npublic class MyClass {\n    private int x;\n    \n    // Copy constructor\n    public MyClass(MyClass obj) {\n        this.x = obj.x;  // Copy state from obj\n    }\n}\n```",
    "topic": "oop"
  },
  {
    "title": "Destructors in Java",
    "question": "Is there a destructor concept in Java?",
    "answer": "No, Java does not have a destructor concept like some other programming languages such as C++. In Java, objects are automatically garbage collected by the JVM (Java Virtual Machine) when they are no longer referenced or needed.\n\nThere was finalize() method as a workaround for the java destructor but it is also deprecated since Java 9.",
    "topic": "oop"
  },
  {
    "title": "Encapsulation Example",
    "question": "Can you provide an example of encapsulation in Java?",
    "answer": "Encapsulation example in Java:\n```java\nclass Person {\n    // Private data members\n    private String name;\n    private int age;\n\n    // Constructor\n    public Person(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n\n    // Public methods to access private data\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    public void setAge(int age) {\n        if (age > 0) {\n            this.age = age;\n        }\n    }\n}\n```\n\npublic class EncapsulationExample {\n    public static void main(String[] args) {\n\n        //Think of a capsule as a person.\n        // The person's name and age are private information,\n        // and they have methods to get or update this information safely.\n        Person person = new Person(\"John\", 30);\n        System.out.println(\"Name: \" + person.getName());\n        System.out.println(\"Age: \" + person.getAge());\n\n        person.setAge(35); // updating age\n        System.out.println(\"Updated Age: \" + person.getAge());\n    }\n}",
    "topic": "oop"
  }
]
